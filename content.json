{"meta":{"title":"兜里没糖","subtitle":"","description":"","author":"aliya","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-03-10T05:09:15.000Z","updated":"2020-03-10T05:15:58.130Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-10T05:12:35.000Z","updated":"2020-03-10T05:14:56.020Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter踩坑","slug":"Flutter踩坑","date":"2020-04-04T16:00:00.000Z","updated":"2020-04-05T17:11:34.830Z","comments":true,"path":"2020/04/05/Flutter踩坑/","link":"","permalink":"http://yoursite.com/2020/04/05/Flutter%E8%B8%A9%E5%9D%91/","excerpt":"","text":"More than one file was found with OS independent path ‘META-INF/proguard/androidx-annotations.pro’解决：在app下build.gradle文件中的android{}下添加：packagingOptions {exclude ‘META-INF/proguard/androidx-annotations.pro’} adb devices命令不存在解决：需要在bash_profile中配置路径，如果终端使用的shell是zsh，则修改对应zsh的配置文件；(切换bash命令：chsh -s /bin/zsh 或 chsh -s /bin/bash)配置路径：// androidexport ANDROID_HOME=本地Android SDK路径（例如：/Users/***/Library/Android/sdk）export PATH=${PATH}:${ANDROID_HOME}/toolsexport PATH=${PATH}:${ANDROID_HOME}/platform-tools Android Studio开启无线调试前提：手机和电脑在同一局域网中；1、终端使用adb devices判断设备是否连接成功，如果连接成功;2、为设备设置一个Tcp/Ip 的侦听端口(adb tcpip 8889);如果成功侦听，终端会返回：restarting in TCP mode port: 8889;3、查看手机的网络IP地址；例如：(192 .168.0.110);4、连接手机的IP和端口：adb connect 192.168.0.110:8889;如果成功连接，终端会返回：already connected to 192.168.0.110:8889;5、通过adb devices查看是否连接成功;6、如果要断开某手机连接：adb disconnect 192.168.0.110:8889;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/categories/Flutter/"}],"tags":[{"name":"Flutter、Dart","slug":"Flutter、Dart","permalink":"http://yoursite.com/tags/Flutter%E3%80%81Dart/"}]},{"title":"WebView交互","slug":"WebView交互","date":"2020-03-19T16:00:00.000Z","updated":"2020-03-26T13:31:43.450Z","comments":true,"path":"2020/03/20/WebView交互/","link":"","permalink":"http://yoursite.com/2020/03/20/WebView%E4%BA%A4%E4%BA%92/","excerpt":"","text":"WKWebView与UIWebViewUIWebView在iOS2就推出了，iOS7以前JS对OC的回调都是基于URL的拦截进行的操作，OC调用JS方法在UIWebView本身提供API：stringByEvaluatingJavaScriptFromString；WKWebView是Apple在iOS8推出的Webkit框架中的负责网页的渲染与展示的类，相比UIWebView速度更快，占用内存更少，支持更多的HTML特性。WKWebView只支持代码创建。 JS与OC互调拦截URL方式、URL劫持 (WebViewJavascriptBridge)在iOS7之前， Web页面和原生代码之间的一个桥梁就是WebViewJavascriptBridge，用来传输一些数据和方法的调用。WebViewJavascriptBridge的原理是iOS与前端首先定好一个scheme（scheme://BRIDGE_LOADED），加载一个特定标识的URL时，在UIWebView的代理方法shouldStartLoadWithRequest拦截URL；通过UIWebView的 stringByEvaluatingJavaScriptFromString方法执行js。在WKWebView中也支持使用拦截的方式来做方法的调用，只是WKWebView是在decidePolicyForNavigationAction的代理方法中拦截URL； OC调用JS1[webView stringByEvaluatingJavaScriptFromString:@&quot;OCToJS(&#39;OC拦截到了我&#39;)&quot;]; JS调用OC1234567891011- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; NSString *requestString &#x3D; [[[request URL] absoluteString]stringByRemovingPercentEncoding]; &#x2F;&#x2F; 拦截url if ([requestString hasSuffix:@&quot;js_native:&#x2F;&#x2F;jsToOC&quot;]) &#123; &#x2F;&#x2F; oc调用js方法 [webView stringByEvaluatingJavaScriptFromString:@&quot;OCToJS(&#39;OC拦截到了我&#39;)&quot;]; return NO; &#125; return YES;&#125; 12345678910&lt;!-- js调用oc --&gt;&lt;button onClick&#x3D;&quot;JSToOC()&quot;&gt;JS调用OC方法&lt;&#x2F;button&gt;&#x2F;&#x2F; js调用ocfunction JSToOC() &#123; window.location.href &#x3D; &quot;js_native:&#x2F;&#x2F;jsToOC&quot;;&#125;&#x2F;&#x2F; oc调用jsfunction OCToJS(param) &#123; alert(param)&#125; JavaScriptCoreJavaScriptCore是从iOS7开始加入的，用Objective-C把WebKit的JavaScript引擎封装了一下，提供了简单快捷的方式与JavaScript交互。使用到的框架是：JavaScriptCore.framework。 OC调用JS提供了两种方式：evaluateScript、callWithArguments 123456789&lt;!-- oc代码 --&gt;- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; JSContext *context &#x3D; [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; &#x2F;* OC调用JS *&#x2F; &#x2F;&#x2F; 第一种方式：evaluateScript [context evaluateScript:@&quot;OCToJS(&#39;evaluateScript&#39;)&quot;]; &#x2F;&#x2F; 第二种方式：callWithArguments [context[@&quot;OCToJS&quot;] callWithArguments:@[@&quot;callWithArguments&quot;]];&#125; 1234&lt;!-- js代码 oc调用js --&gt;function OCToJS(param) &#123; alert(param);&#125; JS调用OC12&lt;!-- js代码 js调用oc --&gt;&lt;button onClick&#x3D;&quot;JSToOC(&#39;success&#39;)&quot;&gt;JS调用OC方法&lt;&#x2F;button&gt; 1234567891011&lt;!-- oc代码 --&gt;- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; JSContext *context &#x3D; [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; &#x2F;* JS调用OC *&#x2F; context[@&quot;JSToOC&quot;] &#x3D; ^() &#123; NSArray *args &#x3D; [JSContext currentArguments]; for (id obj in args) &#123; NSLog(@&quot;%@&quot;,obj); &#x2F;&#x2F; success &#125; &#125;;&#125; WKWebView (WKScriptMessageHandler)在 WKWebView 中不支持获取 JavascriptCore，但是其提供了一套 Message Handler 协议的方式来进行客户端与 JS 的通信; WebKit的库中有个代理WKScriptMessageHandler就是专门来做交互的。WKScriptMessageHandler其实就是一个遵循的协议，它能让网页通过JS把消息发送给OC。 OC调用JS123456- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; [self.webView evaluateJavaScript:@&quot;OCToJS(&#39;OC发送了方法&#39;)&quot; completionHandler:^(id _Nullable ret, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,ret); &#125;];&#125; 12345&#x2F;&#x2F; oc调用jsfunction OCToJS(param) &#123; let res &#x3D; &#39;JS接受到了:&#39;+param return res&#125; JS调用OC12&lt;!-- js代码 --&gt;window.webkit.messageHandlers.jsCallOC.postMessage(&#123;&#39;name&#39;:&#39;yilan&#39;,&#39;id&#39;:&#39;1&#39;&#125;); 12345678910111213141516171819202122&lt;!-- oc代码 --&gt;#pragma mark - WKWebView懒加载- (WKWebView *)webView &#123; if (!_webView) &#123; WKWebViewConfiguration *configuration &#x3D; [[WKWebViewConfiguration alloc] init]; configuration.userContentController &#x3D; [[WKUserContentController alloc]init]; [configuration.userContentController addScriptMessageHandler:self name:@&quot;jsCallOC&quot;]; _webView &#x3D; [[WKWebView alloc]initWithFrame:CGRectZero configuration:configuration]; _webView.navigationDelegate &#x3D; self; _webView.UIDelegate &#x3D; self; &#125; return _webView;&#125;#pragma mark - WKScriptMessageHandler- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; NSString *methods &#x3D; [NSString stringWithFormat:@&quot;%@:&quot;, message.name]; if ([methods isEqualToString:@&quot;jsCallOC:&quot;]) &#123; NSLog(@&quot;执行jsCallOC %@ %@&quot;, message.body[@&quot;name&quot;], message.body[@&quot;id&quot;]); &#125;&#125; github上提供了一个简单的demo实例，有需要的可以查看：Demo实例 参考资料参考资料参考资料","categories":[{"name":"WebView","slug":"WebView","permalink":"http://yoursite.com/categories/WebView/"}],"tags":[{"name":"JS与OC互调","slug":"JS与OC互调","permalink":"http://yoursite.com/tags/JS%E4%B8%8EOC%E4%BA%92%E8%B0%83/"}]},{"title":"iOS中的多线程和异步操作实现同步执行","slug":"iOS的异步操作同步执行","date":"2020-02-27T02:54:28.000Z","updated":"2020-03-10T05:14:17.310Z","comments":true,"path":"2020/02/27/iOS的异步操作同步执行/","link":"","permalink":"http://yoursite.com/2020/02/27/iOS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C/","excerpt":"","text":"iOS多线程 线程：任务执行的最小单位；主线程：用于执行用户UI的重要操作，耗时操作不要放在主线程，否则会卡死；多线程：为了解决耗时操作执行的问题，引入了多线程；线程分为同步执行和异步执行；同步和异步：同步指的是任务会立即在该线程执行，不会开辟新线程；异步指的是不一定会立即执行，可能会开辟新线程；队列：队列是用来管理线程执行的；队列分为串行队列和并行队列；串行队列指的是按顺序执行；并行队列是可以同时执行；主队列: iOS中主队列只会在主线程上执行，不能在同步执行主队列，会造成死锁；参考资料 GCD中的队列：1、主队列 dispatch_main_queue(); 串行,用于更新UI；2、全局队列 dispatch_global_queue(); 并行,四个优先级: background,low,default,high；3、自定义队列 dispatch_queue_t queue; 可以自定义是并行: DISPATCH_QUEUE_CONCURRENT 或者串行 DISPATCH_QUEUE_SERIAL 引用掘金的一副图片：资料路径 iOS异步操作同步执行在进行网络请求中，我们会经常因为业务需要对接口请求做不同的处理；以下主要介绍两类：多个网络请求在全部都得到响应后做业务处理、多个网络请求（数据相互依赖）要求实现同步执行； 信号量(Semaphore)队列组 多个网络请求在全部都得到响应后做业务处理1、信号量和队列组结合2、队列组(dispatch_group_t) 结果：网络请求返回顺序是无序的，等所有网络请求都拿到结果后会走group的notify方法； 多个网络请求（数据相互依赖）要求实现同步执行 - (同步队列异步执行)同上操作：结果：网络请求都是顺序执行","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Vue常用依赖","slug":"Vue常用依赖","date":"2020-01-19T16:00:00.000Z","updated":"2020-04-05T12:02:50.310Z","comments":true,"path":"2020/01/20/Vue常用依赖/","link":"","permalink":"http://yoursite.com/2020/01/20/Vue%E5%B8%B8%E7%94%A8%E4%BE%9D%E8%B5%96/","excerpt":"","text":"vuex作用：vue状态管理安装：npm install vuex –save开源地址：github文档：https://vuex.vuejs.org/zh/ vue-resource作用：通过XMLHttpRequest或JSONP发起请求并处理响应安装：npm install vue-resource –save开原地址：github vue-router作用：路由，控制页面跳转安装：npm install vue-router –save开原地址：github文档：https://router.vuejs.org/zh-cn/ babel-runtime作用：将es6编译成es5去运行，前端可以使用es6的语法来写，最终浏览器上运行的是es5安装：npm install –save babel-runtime babel-polyfill作用：Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片安装：npm install –save-dev babel-polyfill fastclick作用：处理移动端 click 事件 300 毫秒延迟。说明： 为什么存在延迟？从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。为什么这么设计呢？ 因为它想看看你是不是要进行双击（double tap）操作。安装：npm install fastclick -D开源地址：github axios作用：请求数据安装：npm install –save axios开源地址：github文档：https://www.kancloud.cn/yunye/axios/234845 lodash作用：Lodash是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。安装：npm i –save lodash开源地址：github文档：http://www.css88.com/doc/lodash/","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"依赖","slug":"依赖","permalink":"http://yoursite.com/tags/%E4%BE%9D%E8%B5%96/"}]},{"title":"微信小程序开发","slug":"微信小程序开发","date":"2020-01-06T16:00:00.000Z","updated":"2020-03-20T04:15:33.270Z","comments":true,"path":"2020/01/07/微信小程序开发/","link":"","permalink":"http://yoursite.com/2020/01/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/","excerpt":"","text":"接口请求使用 Authorization 进行授权在做微信小程序时，需要使用 Authorization 进行授权，结果每次登录的时候都出现授权弹窗。解决：使用Authorization 授权时，会将用户名和密码用 base64 进行编码然后放到 header 中传入后端代码， header: { ‘Content-Type’: ‘application/json’, ‘Authorization’: ‘Basic ‘ + base64Code, },验证方式：在服务端也会有固定的用户名密码，与之比较，相同则身份通过，否则不通过才会出现授权弹窗。参考资料1参考资料2 微信小程序授权注册流程1、获取code，换取openId wx.login({ success: res =&gt; { // 发送 res.code 到后台换取 openId, sessionKey, unionId } })2、拉取授权授权分为两种：用户信息授权和手机号授权；微信授权的拉取必须使用button控件； 12&lt;button type&#x3D;&#39;primary&#39; open-type&#x3D;&quot;getUserInfo&quot; bindgetuserinfo&#x3D;&quot;getUserInfo&quot;&gt;&lt;button type&#x3D;&#39;primary&#39; open-type&#x3D;&quot;getPhoneNumber&quot; bindgetphonenumber&#x3D;&quot;getPhoneNumber&quot;&gt; 用户信息授权直接可以在回调中获取到，但是手机号授权拿到的是一个加密的串，需要通过后台接口（session_key、iv、encrypted）进行解密返回手机号； 微信小程序for循环中嵌套for循环如果在外层已经遍历了一次item，里边那层就不能使用item取变量；可以使用wx:for-item声明子元素； 123&lt;block wx:for&#x3D;&quot;&#123;&#123;item.tags&#125;&#125;&quot; wx:for-item&#x3D;&quot;items&quot; wx:key&#x3D;&#39;index&#39;&gt; &lt;view&gt;&#123;&#123;items&#125;&#125;&lt;&#x2F;view&gt;&lt;&#x2F;block&gt;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Texture","slug":"Texture","date":"2019-12-30T06:38:20.000Z","updated":"2020-03-10T05:14:49.530Z","comments":true,"path":"2019/12/30/Texture/","link":"","permalink":"http://yoursite.com/2019/12/30/Texture/","excerpt":"","text":"Texture来源FlexBox布局 iOS 系统默认提供的布局方式有两种：一种是 Frame 这种原始方式，也就是通过设置横纵坐标和宽高来确定布局。另一种是自动布局（Auto Layout），相比较于 Frame 需要指出每个视图的精确位置，自动布局对于视图位置的描述更加简洁和易读，只需要确定两个视图之间的关系就能够确定布局。 前端技术栈的布局方式叫做FlexBox布局；苹果公司基于 Flexbox 的布局思路，又在自动布局之上封装了一层 UIStackView。Flexbox 比自动布局提供了更多、更规范的布局方法，布局方式考虑得更全面，使用起来也更加方便。Flexbox 在 2009 年被 W3C 提出，可以很简单、完整地实现各种页面布局，而且还是响应式的，开始被应用于前端领域，目前所有浏览器都已支持。后来通过 React Native 和 Weex 等框架，它被带入到客户端开发中，同时支持了 iOS 和 Android。 与自动布局思路类似，Flexbox 使用的也是描述性的语言来布局。使用 Flexbox 布局的视图元素叫 Flex 容器（flex container），其子视图元素叫作 Flex 项目（flex item）。Flexbox 布局的主要思想是，通过 Flex 容器设定的属性来改变内部 Flex 项目的宽、高，并调整 flex 项目的位置来填充 flex 容器的可用空间。 阮一峰 布局方式 诞生 Texture 之前叫做AsyncDisplayKit，后改名为Texture； Texture 可以保持最复杂的用户界面的流畅和响应。基于 Flexbox 的布局思路，Texture 框架的布局方案虽然学习成本会高一些，但是性能远好于苹果的自动布局，而且写起来更简单。 Texture介绍Texture概念 官方文档 Texture的基本单位就是node（节点）， ASDisplayNode可以看成是一个抽象UIView或者抽象的CALayer。不同点是nodes是线程安全的：可以在后台线程上并行实例化和配置它们的整个层次结构。 Texture 几乎涵盖了常用的控件，下面是 Texture 和 UIKit 的对应关系。 Nodes Texture UIKit ASDisplayNode UIView ASCellNode UITableViewCell/UICollectionViewCell ASTextNode UILabel ASButtonNode UIButton ASImageNode UIImageView ASNetworkImageNode UIImageView ASMultiplexImageNode UIImageView ASVideoNode AVPlayerLayer ASControlNode UIControl ASScrollNode UIScrollView ASEditableTextNode UITextView Node Containers Texture UIKit ASViewController UIViewController ASCellNode ASTableNode/UITableView ASCollectionNode UICollectionView ASPagerNode UICollectionView 布局思路 Texture 框架的布局中，Texture 考虑到布局扩展性，提供了一个基类 ASLayoutSpec。这个基类 提供了布局的基本能力，使 Texture 可以通过它扩展实现多种布局思路，比如 Wrapper、Inset、Overlay、Ratio、Relative、Absolute 等布局思路，也可以继承 ASLayoutSpec 来自定义你的布局算法。 ASLayoutSpec子类 12345678910ASAbsoluteLayoutSpec &#x2F;&#x2F; 绝对布局ASBackgroundLayoutSpec &#x2F;&#x2F; 背景布局ASInsetLayoutSpec &#x2F;&#x2F; 边距布局ASOverlayLayoutSpec &#x2F;&#x2F; 覆盖布局ASRatioLayoutSpec &#x2F;&#x2F; 比例布局ASRelativeLayoutSpec &#x2F;&#x2F; 顶点布局ASCenterLayoutSpec &#x2F;&#x2F; 居中布局ASStackLayoutSpec &#x2F;&#x2F; 盒子布局ASWrapperLayoutSpec &#x2F;&#x2F; 填充布局ASCornerLayoutSpec &#x2F;&#x2F; 角标布局 Texture使用Texture安装1pod &quot;Texture&quot; Texture使用1#import &lt;AsyncDisplayKit &#x2F; AsyncDisplayKit.h&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS布局方式","slug":"iOS布局方式","permalink":"http://yoursite.com/tags/iOS%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"}]},{"title":"iOS项目开发总结","slug":"iOS项目开发总结","date":"2019-12-29T16:00:00.000Z","updated":"2020-03-17T16:51:30.460Z","comments":true,"path":"2019/12/30/iOS项目开发总结/","link":"","permalink":"http://yoursite.com/2019/12/30/iOS%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/","excerpt":"","text":"iOS项目创建项目配置 配置AppIcon和LaunchImage AppIcon: 生成器：App Icon Gear LaunchScreen: 1.在LaunchScreen.storyboard中拖拽imageView并设置约束，取消勾选右侧Use as launch Screen。 2.置空路径Launch Screen File。 3.最后在工程 targets–Build Settings 搜索 Asset Catalog Launch Image Set Name 然后设置Launch Image 就可以了。 从2020年4月开始，使⽤ iOS13 SDK 的 App 将必须提供 LaunchScreen，而LaunchImage将退出历史的舞台，说明以后启动页要通过LaunchScreen来设置了。 获取其他APP的图片 如果我们手中没有UI素材，可以使用其他APP的图片做测试，这时需要使用到以下的工具： Apple Configurator工具 Cartool工具 Apple Configurator工具 文件目录： ~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ Cartool工具 CarTool工具 解压Assets.car文件 书写规范视图创建 xib里 file’s owner class 与 custom class 的区别xib文件本身可以看做是一个xml，app启动的时候会根据xml构造xib对应的界面及其控件，file’s owner 可以看做是xib对应的类，连接outlet控件需要设置；custom class的作用：view本身是UIView, 在代码中使用时, 要使用指定的类型方法, 需要设置custom class为某类型； iOS报错问题总结 真机调试报错：dyld: Library not loaded: @rpath/Bagel.framework/Bagel真机需要将有问题的framework直接引用，在targets-&gt;Build Phases -&gt;Link Binary With Libraries 中添加的第三方库，针对有问题的framework，把status选成optional。iOS真机调试错误Reason: no suitable image found. Did find:删除APP重新安装，因为你的证书在上一次安装到现在安装失败这段时间里证书被重置过，两次的签名不一样，而Bundle identifier ID又是同一个，所以安装会失败。 iOS清除缓存命令rm -rf “$(getconf DARWIN_USER_CACHE_DIR)/org.llvm.clang/ModuleCache”rm -rf ~/Library/Developer/Xcode/DerivedDatarm -rf ~/Library/Caches/com.apple.dt.Xcode","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"项目配置","slug":"项目配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"}]},{"title":"iOS13适配","slug":"iOS13适配","date":"2019-12-23T01:23:27.000Z","updated":"2020-03-22T15:02:07.980Z","comments":true,"path":"2019/12/23/iOS13适配/","link":"","permalink":"http://yoursite.com/2019/12/23/iOS13%E9%80%82%E9%85%8D/","excerpt":"","text":"KVC限制，私有API被封禁iOS13不支持使用KVC进行属性访问和设置了，需要修改为其它方式；例如修改UITextField的内部信息时候，不能使用KVC修改，可通过属性字符串来修改； 黑暗模式iOS13推出了黑暗模式，如果不打算适配 Dark Mode，可以直接在 Info.plist 中添加一栏：User Interface Style : Light，即可在应用内禁用暗黑模式； 即将废弃的LaunchImage在iOS8的时候，苹果就引入了LaunchScreen来设置启动页；同样我们也可以使用LaunchImage，不过需要提供各种屏幕尺寸的启动页图片；而LaunchScreen支持AutoLayout+SizeClass，使用更加方便。不过从2020年4月开始，所有使用iOS13 SDK的APP将必须提供LaunchScreen； presentViewController弹出方式和消失方式iOS13会发现presentViewController的弹出方式不同，是因为modalPresentationStyle属性在之前默认是UIModalPresentationFullScreen，而iOS13改为UIModalPresentationAutomatic；若想全屏展示，需手动修改弹出方式为UIModalPresentationFullScreen，且需要自己做适配： 123UINavigationController *nav &#x3D; [[UINavigationController alloc] initWithRootViewController:vc];nav.modalPresentationStyle &#x3D; UIModalPresentationFullScreen;[self presentViewController:nav animated:YES completion:nil]; 如果使用UIModalPresentationAutomatic为默认弹出方式，则弹窗的消失方式支持下滑消失，是因为UIViewController添加了modalInPresentation属性，默认为false，支持下滑消失，如果不想支持，需手动设置为true； 123if (@available(iOS 13.0, *)) &#123; self.modalInPresentation &#x3D; true;&#125; UISegmentedControl样式UISegmentedControl默认样式为无色； 第三方登录当 Sign In with Apple 服务正式上线以后，接入第三方登录的APP都需要接入苹果登录，且置于最前； 蓝牙权限申请iOS13后需要在info.plist添加NSBluetoothAlwaysUsageDescription字段，说明使用目的； UIWebView将被禁止提交审核在 iOS 13 推出后，苹果在 UIWebView 的说明上将其支持的系统范围定格在了 iOS 2 ~ iOS 12。修改方式：用 WKWebView 替代 UIWebView，确保所有 UIWebView 的 api 都要移除； MPMoviePlayerController被废弃MPMoviePlayerController在iOS13被废弃，替代的是AVPlayerViewController； UISearchDisplayController被废弃解决方案：使用 UISearchController 替换 UISearchBar + UISearchDisplayController 的组合方案； 参考资料1参考资料2 升级XCode10以后项目报错Xcode 10 Error:Multiple commands produce问题及解决方案Xcode 10报错：在工程的配置中有非法的LICENSE和Info.plist。解决方案：找到工程-&gt;主 Target -&gt;Build Phases-&gt;Copy Bundle Resources。删除非法的LICENSE和Info.plist配置，重新编译工程就可以了。参考链接 XCode11 提示”String” file not found之错误解决 #include //file not found参考链接 dyld: Library not loaded: @rpath/ iOS 13.3.1真机系统版本升到iOS 13.3.1后，苹果禁止在免费账户上使用外部框架;解决方法：1、换一个付费的开发者账号；2、不用use_frameworks! 将use_frameworks!替换成use_modular_headers!，重新pod install。 ERROR:”…[CP] Copy Pods Resources”XCode10后默认使用New Build System编译，与旧版Xcode项目编译的规则不一定兼容，所以会出现上述错误。解决：[CP] Copy Pods Resources 删掉Output File List参考链接","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS13适配","slug":"iOS13适配","permalink":"http://yoursite.com/tags/iOS13%E9%80%82%E9%85%8D/"}]},{"title":"iOS基础知识回顾总结","slug":"iOS基础知识回顾总结","date":"2019-12-20T15:46:08.000Z","updated":"2020-03-10T05:14:23.670Z","comments":true,"path":"2019/12/20/iOS基础知识回顾总结/","link":"","permalink":"http://yoursite.com/2019/12/20/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"感想道阻且长，行则将至 心存敬畏之心，方能行有所止面试题 property的修饰符有哪些？并说明其区别？ atomic和nontomic的区别是什么？ iOS实现多线程的方式有哪些？举例说明。 dispatch的线程组使用过吗？怎么使用，有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？ 在使用自动布局的时候有没有遇到过什么问题？ iOS13的新特性？ Git和SVN的区别？ iOS中协议除了在代理中使用还有什么作用？ 说说你对代理的理解，如果一个view（a）要传值给另一个view（b），那么谁是谁的代理？ KVC是什么？KVC机制的原理是什么？如果自己给一个属性重写了getter和setter方法，那么在.m中直接该属性的成员变量会出现什么效果？ 关于 HTTP 请求 GET 和 POST 的区别是什么? 如何把 NSArray 里的 NSNumber 对象以顺序或反序排序? iOS 开发中数据持久化的几种方式。 描述 UITableView的单元格重用机制,以及如何使用。 循环引用的产生原因,以及解决方法。 NSTimer 使用时注意事项? 在某个实例方法中，self.name = _name，name = _name 它们有区别吗，为什么？ 了解GCD的信号量机制吗？ Property属性1、首先解释property，property是iOS用于定义属性，不需要手动编写访问方法，如果需要的话可以重写getter和setter方法；OC提供点语法来访问getter和setter，使用_访问属性则是直接访问底层的存储属性，不会调用setter方法；2、assign、strong、weak、copy、readonly、readwrite、atomic； atomic和nonatomic —— 线程安全方面: atomic是一种多线程保护机制，使得属性具有原子性，防止在未完成赋值的情况下另一个线程读取属性造成的数据错误问题；atomic实际是采用自旋锁的方式，给setter方法加锁，这种方式需要耗费资源，执行效率会变低； 自旋锁与互斥锁的区别：自旋锁指的是在一个线程执行的时候加锁，下一个线程会一直等待；当上一个线程执行完后，下一个线程立即执行；而互斥锁在等待的时候，下一个线程会进入睡眠状态；当上一个线程执行完后，下一个线程才会被唤醒，然后再执行； readwrite和readonly —— 访问权限: readonly只读属性，只会生成getter方法，不会生成setter方法； assign、weak、strong、copy、retain —— 内存管理: assign: 修饰基本数据类型，Int Float 还有id类型 weak: 弱引用，只是单纯引用某个对象，不持有该对象 strong（retain 用于MRC）: 强引用，使对象的引用数据类型+1 assign和weak比较： 相同点：assgin和weak不会牵扯到内存管理，不会增加引用计数 不同点：assign可修饰基本数据类型，也可修饰OC对象，但如果修饰对象类型指向的是一个强指针，当它指向的这个指针释放后，他仍指向这块内存，必须手动给置为nil，否则就会产生野指针，如果还通过此指针操作那块内存，便会导致EXC_BAD_ACCESS错误，调用了已经释放的内存空间；而weak只能修饰OC对象，且相比assign比较安全，如果指向的对象消失了，那么他会自动置为nil，不会产生野指针。 strong和copy比较： 浅拷贝：指针拷贝，不产生新的对象，源对象的引用计数器加1；只是多了一个指向这块内存的指针，共用一块内存。 深拷贝：对象拷贝，会产生新的对象，源对象的引用计数器不变；两块内存是完全不同的，也就是两个对象指针分别指向不同的内存，互不干涉。 判断是浅拷贝和深拷贝就看一下两个变量的内存地址是否一样，一样就是浅拷贝，不一样就是深拷贝，也可以改变一个变量的其中一个属性值看两者的值都会发生变化； 在不可变对象之间进行转换，strong与copy作用是一样的，但是如果在不可变与可变之间进行操作，就需要使用copy,这也就是为什么很多地方用copy，而不是strong修饰 NSString,NSArray等存在可变不可变之分的类对象了，避免出现意外的数据操作.3、引申：block用过吗？修饰block用什么？为什么？ 要使用copy修饰； （1）block内部没有调用外部局部变量时存放在全局区(ARC和MRC下均是) （2）block使用了外部局部变量,这种情况也正是我们平时所常用的方式。MRC：Block的内存地址显示在栈区,栈区的特点就是创建的对象随时可能被销毁,一旦被销毁后续再次调用空对象就可能会造成程序崩溃,在对block进行copy后,block存放在堆区.所以在使用Block属性时使用copy修饰。但是ARC中的Block都会在堆上的，系统会默认对Block进行copy操作 (3）用copy，strong修饰block在ARC和MRC都是可以的，都是在堆区 总结： 1:一共有三种类型的Block.分为NSGlobalBlock,NSStackBlock,NSMallocBlock. 2:没有访问 auto变量 的block 就是 __NSGlobalBlock；访问了auto变量 的block 就是 __NSStackBlock；当一个NSStackBlock调用了copy操作,返回的就是一个__NSMallocBlock； 3:在ARC环境下,编译器会自动把栈上的block copy到堆上。 参考链接：property属性4、引申：iOS中代码创建UIView的时候，使用weak还是strong？ 链接 Git和SVN的区别Git是分布式的，SVN是集中式的；Git和SVN都有集中式版本库和Server端，但Git是分布式管理的，每一个开发者都有一个Local Repository,所以没有网络也可以commit，创建分支，查看历史记录等，等联网以后push到远端即可； iOS中协议和代理的理解协议：可以把协议理解成方法的集合，与Java的接口不同的是，协议可以定义必须实现和非必须实现的方法；代理：一种设计模式，通过协议（Protocal）来实现；让其他类去实现所遵循的协议中的方法；理解成： 一个View有一个事件处理，在view中声明一个协议，在控制器中将view的代理设置为self，这时候self就是该view的代理； 深浅拷贝父类实现深拷贝时，子类如何实现深度拷贝。父类没有实现深拷贝时，子类如何实现深度拷贝。 深拷贝同浅拷贝的区别：浅拷贝是指针拷贝，对一个对象进行浅拷贝，相当于对指向对象的指针进行复制，产生一个新的指向这个对象的指针，那么就是有两个指针指向同一个对象，这个对象销毁后两个指针都应该置空。深拷贝是对一个对象进行拷贝，相当于对对象进行复制，产生一个新的对象，那么就有两个指针分别指向两个对象。当一个对象改变或者被销毁后拷贝出来的新的对象不受影响。 实现深拷贝需要实现NSCoying协议，实现- (id)copyWithZone:(NSZone *)zone 方法。当对一个property属性含有copy修饰符的时候，在进行赋值操作的时候实际上就是调用这个方法。 父类实现深拷贝之后，子类只要重写copyWithZone方法，在方法内部调用父类的copyWithZone方法，之后实现自己的属性的处理 父类没有实现深拷贝，子类除了需要对自己的属性进行处理，还要对父类的属性进行处理。 KVC和KVO KVO，NSNotification，delegate及block区别 KVO就是cocoa框架实现的观察者模式，一般同KVC搭配使用，通过KVO可以监测一个值的变化，比如View的高度变化。是一对多的关系，一个值的变化会通知所有的观察者。 NSNotification是通知，也是一对多的使用场景。在某些情况下，KVO和NSNotification是一样的，都是状态变化之后告知对方。NSNotification的特点，就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO多了发送通知的一步，但是其优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。 delegate 是代理，就是我不想做的事情交给别人做。比如狗需要吃饭，就通过delegate通知主人，主人就会给他做饭、盛饭、倒水，这些操作，这些狗都不需要关心，只需要调用delegate（代理人）就可以了，由其他类完成所需要的操作。所以delegate是一对一关系。 block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且代理的实现更直观。 KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。 Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。 GCD多线程多线程的概念：同步、异步、串行、并行、死锁、队列 1、队列：三种类型：主队列（dispatch_get_main_queue）、全局并发队列（dispath_get_global_queue）、自定义队列（dispatch_queue_create）2、死锁：死锁就是队列引起的循环等待；常见的死锁：主队列同步； 123dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;deallock&quot;);&#125;); 解决：在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。同步对于任务是立刻执行的，那么当把任务放进主队列时，它就会立马执行,只有执行完这个任务，viewDidLoad才会继续向下执行。而viewDidLoad和任务都是在主队列上的，由于队列的先进先出原则，任务又需等待viewDidLoad执行完毕后才能继续执行，viewDidLoad和这个任务就形成了相互循环等待，就造成了死锁。想避免这种死锁，可以将同步改成异步dispatch_async,或者将dispatch_get_main_queue换成其他串行或并行队列，都可以解决。 1234567dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);dispatch_async(serialQueue, ^&#123; dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;deadlock&quot;); &#125;);&#125;); 上面这种情况也会造成死锁；3、GCD执行顺序： 1、串行队列先异步后同步 123456789101112dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;1&quot;);dispatch_async(serialQueue, ^&#123; NSLog(@&quot;2&quot;);&#125;);NSLog(@&quot;3&quot;);dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;4&quot;);&#125;);NSLog(@&quot;5&quot;); 打印结果： 1 3 2 4 5 分析：首先先打印1。接下来将任务2其添加至串行队列上，由于任务2是异步，不会阻塞线程，继续向下执行，打印3然后是任务4,将任务4添加至串行队列上，因为任务4和任务2在同一串行队列，根据队列先进先出原则，任务4必须等任务2执行后才能执行，又因为任务4是同步任务，会阻塞线程，只有执行完任务4才能继续向下执行打印5。 2、performSelector 123dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(test:) withObject:nil afterDelay:0];&#125;); 分析：test方法并不会执行；[performSelector withObject]这个方法本身需要手动添加在runloop中去执行的；而GCD的全局队列所在线程并没有开启runloop，所以不会执行；如果把队列改为dispatch_get_main_queue主队列，由于主队列所在的主线程默认是开启runloop的，所以会之执行test方法；4、dispatch_barrier_async（栅栏函数） 问：怎么用GCD实现多读单写？ 1234567891011121314151617dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);for (NSInteger i &#x3D; 0; i &lt; 10; i++) &#123; dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;%zd&quot;,i); &#125;);&#125;dispatch_barrier_sync(concurrentQueue, ^&#123; NSLog(@&quot;barrier&quot;);&#125;);for (NSInteger i &#x3D; 10; i &lt; 20; i++) &#123; dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;%zd&quot;,i); &#125;);&#125; 分析：这里的dispatch_barrier_sync上的队列要和需要阻塞的任务在同一队列上，否则是无效的。从打印上看，任务0-9和任务任务10-19因为是异步并发的原因，彼此是无序的。而由于栅栏函数的存在，导致顺序必然是先执行任务0-9，再执行栅栏函数，再去执行任务10-19。 而dispatch_barrier_sync和dispatch_barrier_async的区别也就在于会不会阻塞当前线程。比如，上述代码如果在dispatch_barrier_async后随便加一条打印，则会先去执行该打印，再去执行任务0-9和栅栏函数；而如果是dispatch_barrier_sync，则会在任务0-9和栅栏函数后去执行这条打印。 设计多读单写： 123456789101112131415- (id)readDataForKey:(NSString *)key&#123; __block id result; dispatch_sync(_concurrentQueue, ^&#123; result &#x3D; [self valueForKey:key]; &#125;); return result;&#125;- (void)writeData:(id)data forKey:(NSString *)key&#123; dispatch_barrier_async(_concurrentQueue, ^&#123; [self setValue:data forKey:key]; &#125;);&#125;5、dispatch_group_async 场景：在n个耗时并发任务都完成后，再去执行接下来的任务。比如，在n个网络请求完成后去刷新UI页面； 12345678910111213dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;test1&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_group_t group &#x3D; dispatch_group_create();for (NSInteger i &#x3D; 0; i &lt; 10; i++) &#123; dispatch_group_async(group, concurrentQueue, ^&#123; sleep(1); NSLog(@&quot;%zd:网络请求&quot;,i); &#125;);&#125;dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新页面&quot;);&#125;);6、Dispatch Semaphore GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。 Dispatch Semaphore 提供了三个函数： 1.dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量 2.dispatch_semaphore_signal：发送一个信号，让信号总量加1 3.dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。 Dispatch Semaphore 在实际开发中主要用于： 1、保持线程同步，将异步执行任务转换为同步执行任务 2、保证线程安全，为线程加锁 例如： 12345678910111213- (void)asyncTask&#123; dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER); count++; sleep(1); NSLog(@&quot;执行任务:%zd&quot;,count); dispatch_semaphore_signal(_semaphore);&#125;for (NSInteger i &#x3D; 0; i &lt; 100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self asyncTask]; &#125;);&#125; 分析：然后发现打印是从任务1顺序执行到100，没有发生两个任务同时执行的情况； 原因如下:在子线程中并发执行asyncTask，那么第一个添加到并发队列里的，会将信号量减1，此时信号量等于0，可以执行接下来的任务。而并发队列中其他任务，由于此时信号量不等于0，必须等当前正在执行的任务执行完毕后调用dispatch_semaphore_signal将信号量加1，才可以继续执行接下来的任务，以此类推，从而达到线程加锁的目的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"sass、less、stylus总结","slug":"sass\\less\\stylus总结","date":"2019-12-11T16:00:00.000Z","updated":"2020-03-20T03:43:04.820Z","comments":true,"path":"2019/12/12/sass\\less\\stylus总结/","link":"","permalink":"http://yoursite.com/2019/12/12/sass/less/stylus%E6%80%BB%E7%BB%93/","excerpt":"","text":"CSS预处理程序介绍 CSS预处理程序是基于 CSS 扩展了一套属于自己的 DSL，来解决书写 CSS 时繁杂的问题。 1、语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器； 2、没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。 功能 支持嵌套语法 支持使用运算符 例如less中： 1234 @fontSize: 10px;.myclass &#123; font-size: @fontSize * 2;&#125; 变量 变量为 CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。 可动态构建选择器 混入 混入（mixin）提供了样式层面的抽象。 三大CSS预处理器框架SASS 2007年诞生，是最早的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。 LESS 2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，Bootstrap就是采用LESS做底层语言的。 Stylus 2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。 SASS、LESS、Stylus区别 编译环境不同：Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。Stylus需要安装node，然后安装最新的stylus包即可使用。变量符不同：Less是@，Scss是$，Stylus可以使用“$”符号或者不使用符号，如下：处理条件语句：引入外部CSS文件：scss引用的外部文件命名必须以_开头, 文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件。Less和Stylus引用外部文件可以用@import进行引入。 参考资料","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CSS预处理程序","slug":"CSS预处理程序","permalink":"http://yoursite.com/tags/CSS%E9%A2%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"}]},{"title":"JavaScript基础入门","slug":"JavaScript入门","date":"2019-09-30T16:00:00.000Z","updated":"2020-03-20T03:45:19.960Z","comments":true,"path":"2019/10/01/JavaScript入门/","link":"","permalink":"http://yoursite.com/2019/10/01/JavaScript%E5%85%A5%E9%97%A8/","excerpt":"","text":"基本语法变量 声明变量时候用var命令，变量是有作用域的，分为局部变量和全局变量； 1var a &#x3D; 1; 实际上是执行： 12var a;a &#x3D; 1; 声明变量的时候要声明类型，若不声明类型比如（b = 1;），则是创建了全局变量；JS是动态类型语言，可随时更改变量类型； 变量提升 JavaScript引擎工作方式: 先解析代码，获得所有被声明的变量，然后一行一行执行，变量的声明会被提升到头部，叫做变量提升； 区块 javaScript使用{}作为区块，对于var命令来说，区块不构成单独作用域； 标签 标签（label），定位符，用于跳转到程序任意位置； 数据类型数据类型分类 number string boolean undefined null 对象 symbol(ES6新增)number string boolean 属于基本数据类型；undefined null 属于特殊值；对象包括对象、数组、函数类型； typeof运算符 typeof 123 结果：numbertypeof ‘123’ 结果：stringtypeof false 结果：booleantypeof undefined 结果：undefinedtypeof [] 结果：objecttypeof {} 结果：objecttypeof null 结果：object有上述可见：typeof可以区分出基本数据类型，但无法区分出object和null类型； null和undefinednull == undefined 结果是truenull === undefined 结果是false区别是null转为数值是0，而undefined转为数值是NaN； booleanundefined、null、false、0、NAN、“”或者’’ 转为boolean是false，其他都为true，包括空数组和空对象； 数值类型整型 JavaScript内部所有数字都是以浮点数存储的，底层根本没有整数，所有数字都是小数；整数运算时，会吧64位浮点数转为32位整数再进行计算；例如：1 === 1.0 结果为true1 + 2 === 3.0 结果为true 浮点型 浮点数不是精确值0.1 + 0.2 === 0.3 结果为false NANtypeof NAN 结果为number5 - ‘1’ 结果为45 - ‘x’ 结果为NANNAN不等于任何值，包括它本身； parseIntparseInt(‘123’)parseInt(‘ 123’)parseInt(1.23)parseInt(‘8a’)parseInt(‘abc’)parseInt(‘’)parseInt(‘1000’, 2)parseInt(‘10’, 1)parseInt(‘10’, 0)parseInt(‘1546’,2) 结果分别是： 12312318NaNNaN8NaN101 parseFloatparseFloat(‘3.14’) 3.14parseFloat([]) NaNparseFloat(‘’) NaN isNaNisNaN(NaN) trueisNaN(123) falseisNaN(‘hello’) true 相当于：isNaN(‘hello’) =&gt; isNaN(Number(‘hello’))isNaN({}) true 所以：判断一个数据类型是不是isNaN，有两种方式：1、typeof value == ‘number’ &amp;&amp; isNaN(value) 值是number类型并且isNaN是true2、value !== value 自身不等于自身 字符串数组字符串可以作为数组来使用； 123var s &#x3D; &#39;hello&#39;;s[0] &#x2F;&#x2F; &#39;h&#39;s.length &#x2F;&#x2F; 5 对象对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 生成方式1234var obj &#x3D; &#123; foo: &#39;Hello&#39;, bar: &#39;World&#39;&#125;; 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 &#x3D; &#123;&#125;;var o2 &#x3D; o1;o1.a &#x3D; 1;o2.a &#x2F;&#x2F; 1o2.b &#x3D; 2;o1.b &#x2F;&#x2F; 2 属性的操作读取和赋值均是两种方式：点语法和方括号 属性的查看12345var obj &#x3D; &#123; foo: &#39;Hello&#39;, bar: &#39;World&#39;&#125;Object.keys(obj) 结果：[‘foo’,’bar’] 属性的删除123456789var obj &#x3D; &#123; foo: &#39;Hello&#39;, bar: &#39;World&#39;&#125;Object.keys(obj) &#x2F;&#x2F; [&#39;foo&#39;,&#39;bar&#39;]delete obj.foo &#x2F;&#x2F; trueobj.foo &#x2F;&#x2F; undefinedObject.keys(obj) &#x2F;&#x2F; [&#39;foo&#39;] delete一个不存在的属性也会返回true；delete只能删除对象本身的属性，不能删除继承的属性； 属性是否存在：in运算符123456var obj &#x3D; &#123; foo: &#39;Hello&#39;, bar: &#39;World&#39;&#125;;&#39;foo&#39; in obj &#x2F;&#x2F; true&#39;toString&#39; in obj &#x2F;&#x2F; true 注意点：1、in运算符无法识别属性是对象自身的，还是继承过来的；2、想要判断是否是自身的属性，使用hasOwnProperty,例如hasOwnProperty(‘toString’) 属性的遍历12345678var obj &#x3D; &#123; foo: &#39;Hello&#39;, bar: &#39;World&#39;&#125;;for (var i in obj) &#123; console.log(&#39;键名：&#39;, i); console.log(&#39;键值：&#39;, obj[i]);&#125; 注意点：1、for in遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。2、for in不仅遍历对象自身的属性，还遍历继承的属性。3、对象都继承了toString属性，但是for…in循环不会遍历到这个属性，因为toString默认是“不可遍历”的；所以一般情况下，如果只想遍历对象自身的属性，应结合使用hasOwnProperty方法。 函数JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 声明1、function命令 123function print(s) &#123; console.log(s);&#125; 2、函数表达式 123var print &#x3D; function(s) &#123; console.log(s);&#125;; 重复声明123456789function f() &#123; console.log(1);&#125;f() &#x2F;&#x2F; 2function f() &#123; console.log(2);&#125;f() &#x2F;&#x2F; 2 属性和方法123name属性length属性：length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于定义时的参数个数。toString()方法：返回一个字符串，内容是函数的源码 函数作用域作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域； 全局变量： 123456var v &#x3D; 1;function f() &#123; console.log(v);&#125;f()&#x2F;&#x2F; 1 局部变量： 1234function f()&#123; var v &#x3D; 1;&#125;v &#x2F;&#x2F; ReferenceError: v is not defined 函数本身的作用域：函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 123456789var a &#x3D; 1;var x &#x3D; function () &#123; console.log(a);&#125;;function f() &#123; var a &#x3D; 2; x();&#125;f() &#x2F;&#x2F; 1 123456789var x &#x3D; function () &#123; console.log(a);&#125;;function y(f) &#123; var a &#x3D; 2; f();&#125;y(x)&#x2F;&#x2F; ReferenceError: a is not defined 函数体内部声明的函数，作用域绑定函数体内部: 12345678910function foo() &#123; var x &#x3D; 1; function bar() &#123; console.log(x); &#125; return bar;&#125;var x &#x3D; 2;var f &#x3D; foo();f() &#x2F;&#x2F; 1 闭包闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc &#x3D; createIncrementor(5);inc() &#x2F;&#x2F; 5inc() &#x2F;&#x2F; 6inc() &#x2F;&#x2F; 7 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 数组数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 Object.keys()Object.keys方法返回数组的所有键名，注意：JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]），对于数组的键名，不能使用点结构。 length属性length属性是可写的，可以手动设置；1、如果设置length小于数组长度，会自动减少元素个数为length个；所以清空数组的一个方法就是设置数组的length为0； 12345var arr &#x3D; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];arr.length &#x2F;&#x2F; 3arr.length &#x3D; 2;arr &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;] 2、如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。3、由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。 12345var a &#x3D; [];a[&#39;p&#39;] &#x3D; &#39;abc&#39;;a.length &#x2F;&#x2F; 0a[2.1] &#x3D; &#39;abc&#39;;a.length &#x2F;&#x2F; 0 4、使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 12345var a &#x3D; [1, 2, 3];delete a[1];a[1] &#x2F;&#x2F; undefineda.length &#x2F;&#x2F; 3 也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。如果是空位，使用数组的forEach、for…in、Object.keys方法进行遍历，空位都会被跳过,而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 in运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 1234var arr &#x3D; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];2 in arr &#x2F;&#x2F; true&#39;2&#39; in arr &#x2F;&#x2F; true4 in arr &#x2F;&#x2F; false for…infor…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。而且，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。 12345678910var a &#x3D; [1, 2, 3];a.foo &#x3D; true;for (var key in a) &#123; console.log(key);&#125;&#x2F;&#x2F; 0&#x2F;&#x2F; 1&#x2F;&#x2F; 2&#x2F;&#x2F; foo 所以，不推荐使用for…in遍历数组。 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 1234567891011var obj &#x3D; &#123; 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;, length: 3&#125;;obj[0] &#x2F;&#x2F; &#39;a&#39;obj[1] &#x2F;&#x2F; &#39;b&#39;obj.length &#x2F;&#x2F; 3obj.push(&#39;d&#39;) &#x2F;&#x2F; TypeError: obj.push is not a function “类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 12345var obj &#x3D; &#123; length: 0&#125;;obj[3] &#x3D; &#39;d&#39;;obj.length &#x2F;&#x2F; 0 数组的slice方法可以将“类似数组的对象”变成真正的数组: 1var arr &#x3D; Array.prototype.slice.call(arrayLike); 运算符参考资料","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}